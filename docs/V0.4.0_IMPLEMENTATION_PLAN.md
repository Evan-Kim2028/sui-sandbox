# v0.4.0 Implementation Plan: MM2 Type Validator

## Overview

This document outlines the implementation plan for v0.4.0, which introduces:
1. **Move Model 2 (MM2) integration** for static type validation
2. **Redesigned error taxonomy** with phases and specific error codes
3. **Separation of static type checking from runtime execution**

## Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      v0.4.0 Type Inhabitation Pipeline                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ Phase 1: RESOLUTION                                                  │    │
│  │ - Load target package bytecode                                       │    │
│  │ - Load helper package bytecode (LLM-generated)                       │    │
│  │ - Build MM2 Model from CompiledModules                               │    │
│  │                                                                      │    │
│  │ Errors: E101_ModuleNotFound, E102_FunctionNotFound, E103_NotCallable │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                                    ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ Phase 2: TYPE CHECK (NEW - MM2 Static Validation)                    │    │
│  │ - Validate function signatures match                                 │    │
│  │ - Check generic instantiation validity                               │    │
│  │ - Verify ability constraints (copy/drop/store/key)                   │    │
│  │ - Validate constructor chain types                                   │    │
│  │                                                                      │    │
│  │ Errors: E201_TypeMismatch, E202_AbilityViolation, E203_GenericBounds │    │
│  │         E204_RecursiveType, E205_UnknownType                         │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                                    ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ Phase 3: SYNTHESIS                                                   │    │
│  │ - Find constructor chains for required types                         │    │
│  │ - Generate default values for primitives                             │    │
│  │ - Build BCS-serialized arguments                                     │    │
│  │                                                                      │    │
│  │ Errors: E301_NoConstructor, E302_ChainTooDeep, E303_UnsupportedParam │    │
│  │         E304_BCSSerializationFailed                                  │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                                    ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ Phase 4: EXECUTION (Optional - can skip with --static-only)          │    │
│  │ - Execute constructor chain in VM                                    │    │
│  │ - Execute target function                                            │    │
│  │ - Capture execution trace                                            │    │
│  │                                                                      │    │
│  │ Errors: E401_VMSetupFailed, E402_ConstructorAborted,                 │    │
│  │         E403_TargetAborted, E404_UnsupportedNative                   │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                                    ▼                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ Phase 5: VALIDATION                                                  │    │
│  │ - Verify target modules were accessed                                │    │
│  │ - Check return types match expectations                              │    │
│  │                                                                      │    │
│  │ Errors: E501_NoTargetAccess, E502_ReturnTypeMismatch                 │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                    │                                         │
│                                    ▼                                         │
│                         TYPE INHABITATION SUCCESS                            │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

## File Structure

```
src/benchmark/
├── mod.rs                    # Module exports
├── errors.rs                 # NEW: Redesigned error taxonomy
├── phases/                   # NEW: Phase-based organization
│   ├── mod.rs
│   ├── resolution.rs         # Phase 1: Module/function resolution
│   ├── typecheck.rs          # Phase 2: MM2 static type validation (NEW)
│   ├── synthesis.rs          # Phase 3: Value synthesis
│   ├── execution.rs          # Phase 4: VM execution
│   └── validation.rs         # Phase 5: Result validation
├── mm2/                      # NEW: MM2 integration
│   ├── mod.rs
│   ├── model.rs              # MM2 Model wrapper
│   ├── type_validator.rs     # Static type checking logic
│   └── constructor_graph.rs  # Constructor dependency graph
├── runner.rs                 # Orchestrates phases
├── vm.rs                     # VM harness (existing)
├── natives.rs                # Native functions (existing)
├── object_runtime.rs         # Dynamic fields (existing)
├── resolver.rs               # Module loading (existing)
└── constructor_map.rs        # Constructor discovery (refactor to use MM2)
```

## Implementation Milestones

### Milestone 1: Error Taxonomy Redesign (Day 1)

**Files to modify:**
- `src/benchmark/errors.rs` - Complete rewrite

**New error structure:**
```rust
/// Phase of the type inhabitation pipeline
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
pub enum Phase {
    Resolution,
    TypeCheck,
    Synthesis,
    Execution,
    Validation,
}

/// Specific error codes within each phase
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
pub enum ErrorCode {
    // Resolution (1xx)
    E101_ModuleNotFound,
    E102_FunctionNotFound,
    E103_NotCallable,

    // TypeCheck (2xx)
    E201_TypeMismatch,
    E202_AbilityViolation,
    E203_GenericBounds,
    E204_RecursiveType,
    E205_UnknownType,

    // Synthesis (3xx)
    E301_NoConstructor,
    E302_ChainTooDeep,
    E303_UnsupportedParam,
    E304_BCSFailed,

    // Execution (4xx)
    E401_VMSetupFailed,
    E402_ConstructorAborted,
    E403_TargetAborted,
    E404_UnsupportedNative,

    // Validation (5xx)
    E501_NoTargetAccess,
    E502_ReturnTypeMismatch,
}

/// Complete failure information
#[derive(Debug, Clone, Serialize)]
pub struct Failure {
    pub phase: Phase,
    pub code: ErrorCode,
    pub message: String,
    pub is_expected_limitation: bool,  // true for unsupported natives, etc.
}
```

### Milestone 2: Add MM2 Dependency (Day 1)

**Files to modify:**
- `Cargo.toml` - Add move-model-2 dependency

```toml
# Add to Cargo.toml
move-model-2 = { git = "https://github.com/MystenLabs/sui", tag = "mainnet-v1.62.1", package = "move-model-2" }
```

**Verify compilation works with new dependency.**

### Milestone 3: MM2 Model Integration (Day 2)

**Files to create:**
- `src/benchmark/mm2/mod.rs`
- `src/benchmark/mm2/model.rs`

**Key functionality:**
```rust
/// Wrapper around MM2's Model for our use case
pub struct TypeModel {
    model: move_model_2::Model<WithoutSource>,
    summary: move_model_2::summary::Packages,
}

impl TypeModel {
    /// Build model from compiled modules (no source required)
    pub fn from_modules(modules: Vec<CompiledModule>) -> Result<Self>;

    /// Get function signature
    pub fn get_function(&self, module: &ModuleId, name: &str) -> Option<&summary::Function>;

    /// Get struct definition
    pub fn get_struct(&self, module: &ModuleId, name: &str) -> Option<&summary::Struct>;

    /// Check if type A can be assigned to type B
    pub fn types_compatible(&self, from: &Type, to: &Type) -> bool;

    /// Check ability constraints
    pub fn check_abilities(&self, ty: &Type, required: AbilitySet) -> Result<()>;
}
```

### Milestone 4: Static Type Validator (Day 2-3)

**Files to create:**
- `src/benchmark/mm2/type_validator.rs`

**Key functionality:**
```rust
pub struct TypeValidator<'a> {
    model: &'a TypeModel,
}

impl<'a> TypeValidator<'a> {
    /// Validate a function call is type-correct
    pub fn validate_call(
        &self,
        target: &FunctionRef,
        type_args: &[Type],
        arg_types: &[Type],
    ) -> Result<(), Failure>;

    /// Validate constructor chain produces correct types
    pub fn validate_constructor_chain(
        &self,
        chain: &[ConstructorCall],
        final_type: &Type,
    ) -> Result<(), Failure>;

    /// Check generic instantiation is valid
    pub fn validate_generic_instantiation(
        &self,
        type_params: &[TParam],
        type_args: &[Type],
    ) -> Result<(), Failure>;
}
```

### Milestone 5: Phase-Based Runner Refactor (Day 3-4)

**Files to create:**
- `src/benchmark/phases/mod.rs`
- `src/benchmark/phases/resolution.rs`
- `src/benchmark/phases/typecheck.rs`
- `src/benchmark/phases/synthesis.rs`
- `src/benchmark/phases/execution.rs`
- `src/benchmark/phases/validation.rs`

**Files to modify:**
- `src/benchmark/runner.rs` - Refactor to use phases

**New runner structure:**
```rust
pub struct PipelineResult {
    pub phase_reached: Phase,
    pub failure: Option<Failure>,
    pub type_check_passed: bool,
    pub execution_passed: Option<bool>,  // None if skipped
    pub modules_accessed: Vec<ModuleId>,
}

pub fn run_pipeline(
    config: &PipelineConfig,
    target: &FunctionRef,
    helper_bytecode: Option<&[CompiledModule]>,
) -> PipelineResult {
    // Phase 1: Resolution
    let model = match resolution::resolve(config, target, helper_bytecode) {
        Ok(m) => m,
        Err(f) => return PipelineResult::failed(Phase::Resolution, f),
    };

    // Phase 2: Type Check (NEW)
    if let Err(f) = typecheck::validate(&model, target) {
        return PipelineResult::failed(Phase::TypeCheck, f);
    }

    // Phase 3: Synthesis
    let args = match synthesis::synthesize(&model, target) {
        Ok(a) => a,
        Err(f) => return PipelineResult::failed(Phase::Synthesis, f),
    };

    // Phase 4: Execution (optional)
    if !config.static_only {
        if let Err(f) = execution::execute(&model, target, &args) {
            return PipelineResult::failed(Phase::Execution, f);
        }
    }

    // Phase 5: Validation
    if let Err(f) = validation::validate(&model, target) {
        return PipelineResult::failed(Phase::Validation, f);
    }

    PipelineResult::success()
}
```

### Milestone 6: Constructor Graph with MM2 (Day 4)

**Files to create:**
- `src/benchmark/mm2/constructor_graph.rs`

**Key functionality:**
```rust
/// Graph-based constructor discovery using MM2 type info
pub struct ConstructorGraph {
    /// Type -> List of constructors that return it
    constructors: HashMap<TypeKey, Vec<ConstructorInfo>>,
    /// Dependency edges between types
    dependencies: HashMap<TypeKey, Vec<TypeKey>>,
}

impl ConstructorGraph {
    /// Build from MM2 model
    pub fn from_model(model: &TypeModel) -> Self;

    /// Find constructor chain up to max_depth
    pub fn find_chain(
        &self,
        target_type: &Type,
        max_depth: usize,
    ) -> Option<Vec<ConstructorCall>>;

    /// Check if type is synthesizable (has path to primitives)
    pub fn is_synthesizable(&self, ty: &Type) -> bool;
}
```

### Milestone 7: CLI Updates (Day 4-5)

**Files to modify:**
- `src/args.rs` - Add new flags

**New flags:**
```
--static-only     Skip VM execution, only do static type checking
--max-chain-depth Maximum constructor chain depth (default: 3)
--error-format    Output format: legacy | phased | json
```

### Milestone 8: LST Package Testing (Day 5)

**Test plan:**
1. Download LST package bytecode
2. Run benchmark with new pipeline
3. Compare error distribution: old taxonomy vs new phases
4. Verify MM2 type checking catches errors earlier
5. Test with real LLM (OpenRouter) to validate E2E

## Error Taxonomy Mapping

| Old Code | New Code | Phase |
|----------|----------|-------|
| A1 | E101, E102, E103 | Resolution |
| A2 | E204, E205 | TypeCheck |
| A3 | E301, E302, E303 | Synthesis |
| A5 | E203 | TypeCheck |
| B1 | E401, E402 | Execution |
| B2 | E403, E404 | Execution |
| (new) | E201, E202 | TypeCheck |
| (new) | E501, E502 | Validation |

## Success Criteria

1. **All existing tests pass** with new error codes mapped
2. **MM2 model builds** from bytecode without source
3. **Static type checking** catches type errors before VM execution
4. **Constructor graph** supports depth > 1 (configurable)
5. **LST package** runs E2E with real LLM
6. **Error distribution** is more precise (no conflation of error types)

## Dependencies

```toml
# New in Cargo.toml
move-model-2 = { git = "https://github.com/MystenLabs/sui", tag = "mainnet-v1.62.1", package = "move-model-2" }

# May need additional transitive deps
indexmap = { version = "2", features = ["serde"] }
```

## Risks and Mitigations

| Risk | Mitigation |
|------|------------|
| MM2 compile time increase | Profile build, consider feature flags |
| MM2 API changes between Sui versions | Pin to mainnet-v1.62.1, document assumptions |
| Breaking change to error taxonomy | Provide --error-format=legacy flag |
| Constructor graph explosion | Configurable max_depth, cycle detection |

## Timeline

| Day | Milestone | Deliverable |
|-----|-----------|-------------|
| 1 | M1 + M2 | Error taxonomy + MM2 dependency |
| 2 | M3 + M4 (start) | MM2 model wrapper |
| 3 | M4 + M5 (start) | Type validator + phase structure |
| 4 | M5 + M6 | Runner refactor + constructor graph |
| 5 | M7 + M8 | CLI + LST testing |

## Next Steps

1. Start with Milestone 1: Error taxonomy redesign
2. Verify MM2 compiles (Milestone 2)
3. Iterate through remaining milestones
4. Validate with LST package using OpenRouter API
