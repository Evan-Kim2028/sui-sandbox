# Programmable Transaction Block (PTB) Schema

This document defines the technical specification for the JSON PTB plans generated by AI agents and processed by the benchmark harness.

---

## 1. Top-Level Structure

A PTB plan is a JSON object containing an array of function calls.

```json
{
  "calls": [
    {
      "target": "0xADDR::module::function",
      "type_args": ["0x2::sui::SUI", "..."],
      "args": [
        { "u64": 100 },
        { "result": 0 }
      ]
    }
  ]
}
```

### Call Object
- **`target`**: Fully qualified Move function string.
- **`type_args`**: List of TypeTags (e.g., `"0x2::sui::SUI"`).
- **`args`**: List of [Argument Kind](#2-argument-kinds) objects.

---

## 2. Argument Kinds

Arguments are represented as single-key objects.

| Kind | Move Type | Example |
|------|-----------|---------|
| `u8` - `u256` | Integer | `{ "u64": 1000 }` |
| `bool` | Boolean | `{ "bool": true }` |
| `address` | Address | `{ "address": "0x123..." }` |
| `imm_or_owned_object` | Object | `{ "imm_or_owned_object": "0xABC..." }` |
| `shared_object` | Shared Object | `{ "shared_object": { "id": "0x...", "mutable": true } }` |
| `vector_u8_utf8` | `vector<u8>` | `{ "vector_u8_utf8": "hello" }` |
| `vector_u8_hex` | `vector<u8>` | `{ "vector_u8_hex": "0xDEADBEEF" }` |
| `vector_<kind>` | `vector<T>` | `{ "vector_u64": [1, 2] }` |
| `result` | Function Result | `{ "result": 0 }` (Refers to Call 0) |
| `nested_result` | Multi-Return | `{ "nested_result": [0, 1] }` (Call 0, Return 1) |
| `pure` | BCS Bytes | `{ "pure": "0x..." }` |

### Prohibited Kinds
The following kinds are **strictly unsupported** and will cause `smi_tx_sim` to bail:
- `input`, `string`, `object`, `object_id`, `hex`, `pure_u64`.

---

## 3. Normalization Rules

The `normalize.py` module massages model output to focus on **planning logic** rather than JSON pedantry.

### Supported Corrections
1. **Legacy Aliases**: `object` and `object_id` are automatically renamed to `imm_or_owned_object`.
2. **Type Coercion**: Stringified integers or booleans are converted to their native JSON types (e.g., `"100"` -> `100`).
3. **Address Padding**: Addresses missing the `0x` prefix or the full 64-character hex length are padded and prefixed.
4. **Index Correction**: Result references provided as strings (e.g., `{"result": "0"}`) are cast to integers.

---

## 4. Rationale: Why this Schema?

Our schema is designed to be a **strict subset** of the Sui PTB functionality that is easily parseable by both LLMs and Rust. 

- **Why no `input`?**: Standard Sui PTBs distinguish between "Inputs" and "Arguments." To simplify agent planning, our harness treats everything as an "Argument" and handles the input-loading internally.
- **Why no `string`?**: Move does not have a native `string` type (it uses `vector<u8>`). We force models to explicitly use `vector_u8_utf8` to ensure they understand they are working with raw bytes.